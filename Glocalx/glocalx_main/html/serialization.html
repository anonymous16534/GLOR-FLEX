<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>serialization API documentation</title>
<meta name="description" content="Serialize and deserialize objects and rules." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>serialization</code></h1>
</header>
<section id="section-intro">
<p>Serialize and deserialize objects and rules.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Serialize and deserialize objects and rules.&#34;&#34;&#34;
import pickle

from tensorflow.keras.models import load_model as load_tf_model
import numpy as np

import json
import os

from glocalx import GLocalX
from models import Rule


def load_run(run_file):
    &#34;&#34;&#34;
    The rules file output by GLocalX is slightly different than the input one loaded
    with models.Rule.from_json, as it contains additional information on the run, such as
    the input files paths, hyperparameters, etc.
    Args:
        run_file (str): Path to the rules file.

    Returns:
        dict: Dictionary holding the output rules (`rules` key), the oracle, if any, (`black_box`) key,
                the training set (`tr` key) and the undersample (`undersample` key). Note that regardless
                of whether the black box is loaded or not, the training set preserves its original labels.
                If you want to use the training set with the black box labels you have to re-infer them.
    &#34;&#34;&#34;
    if not os.path.isfile(run_file):
        raise ValueError(&#39;File &#39; + str(run_file) + &#39; is not a file.&#39;)
    with open(run_file, &#39;r&#39;) as log:
        dic = json.load(log)

    # Load features names from the training file
    tr_path = dic[&#39;tr&#39;]
    if not os.path.isfile(tr_path):
        raise ValueError(&#39;Training file &#39; + str(tr_path) + &#39; is not a file.&#39;)
    data = np.genfromtxt(tr_path, delimiter=&#39;,&#39;, names=True)
    names = data.dtype.names
    tr_set = data.view(np.float).reshape(data.shape + (-1,))

    # Load rules
    rules = dic[&#39;rules&#39;]
    premises = [{int(k): v for k, v in d.items() if k != &#39;consequence&#39; and k != &#39;label&#39;} for d in rules]
    consequences = [dic[&#39;consequence&#39;] if &#39;consequence&#39; in dic else dic[&#39;label&#39;] for dic in rules]
    rules = [Rule(premises=premise, consequence=consequence, names=names)
             for premise, consequence in zip(premises, consequences)]

    # Load oracle
    oracle = dic[&#39;oracle&#39;]
    if oracle.endswith(&#39;.h5&#39;):
        oracle = load_tf_model(oracle)
    elif oracle.endswith(&#39;.pickle&#39;):
        with open(oracle, &#39;rb&#39;) as log:
            oracle = pickle.load(log)
    else:
        return

    # Load undersample
    undersample = dic[&#39;undersample&#39;]

    results = {
        &#39;rules&#39;: rules,
        &#39;oracle&#39;: oracle,
        &#39;undersample&#39;: undersample,
        &#39;tr&#39;: tr_set
    }

    return results


def load_glocalx(rules, is_glocalx_run=False):
    &#34;&#34;&#34;
    Create a GLocalX instance from `rules_file`. Rules from `rules_file` are considered as
    this instance&#39;s output, i.e. its `self.fine_boundary`.
    Args:
        rules (Union(str, set, list)): Path to rules, or directly set/list of rules.
        is_glocalx_run (bool): Whether the given rule file is the output of a GLocalX run or not.
                                GLocalX stores its output file in a different format than the input
                                rules.

    Returns:
        GLocalX: A GLocalX instance as if it were trained and returned `rules`
    &#34;&#34;&#34;
    if isinstance(rules, str) and not os.path.isfile(rules):
        raise ValueError(&#39;Not a valid file&#39;)

    if isinstance(rules, str):
        if is_glocalx_run:
            run = load_run(rules)
            fine_boundary = run[&#39;rules&#39;]
            glocalx = GLocalX(oracle=run[&#39;oracle&#39;])
        else:
            fine_boundary = Rule.from_json(rules)
            glocalx = GLocalX(oracle=None)
    elif isinstance(rules, set) or isinstance(rules, list):
        fine_boundary = rules
        glocalx = GLocalX(oracle=None)
    else:
        raise ValueError(&#39;Not a str or set or list&#39;)

    # Load rules in the boundary
    glocalx.fine_boundary = fine_boundary

    return glocalx</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="serialization.load_glocalx"><code class="name flex">
<span>def <span class="ident">load_glocalx</span></span>(<span>rules, is_glocalx_run=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a GLocalX instance from <code>rules_file</code>. Rules from <code>rules_file</code> are considered as
this instance's output, i.e. its <code>self.fine_boundary</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt>rules (Union(str, set, list)): Path to rules, or directly set/list of rules.</dt>
<dt><strong><code>is_glocalx_run</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the given rule file is the output of a GLocalX run or not.
GLocalX stores its output file in a different format than the input
rules.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>GLocalX</code></dt>
<dd>A GLocalX instance as if it were trained and returned <code>rules</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_glocalx(rules, is_glocalx_run=False):
    &#34;&#34;&#34;
    Create a GLocalX instance from `rules_file`. Rules from `rules_file` are considered as
    this instance&#39;s output, i.e. its `self.fine_boundary`.
    Args:
        rules (Union(str, set, list)): Path to rules, or directly set/list of rules.
        is_glocalx_run (bool): Whether the given rule file is the output of a GLocalX run or not.
                                GLocalX stores its output file in a different format than the input
                                rules.

    Returns:
        GLocalX: A GLocalX instance as if it were trained and returned `rules`
    &#34;&#34;&#34;
    if isinstance(rules, str) and not os.path.isfile(rules):
        raise ValueError(&#39;Not a valid file&#39;)

    if isinstance(rules, str):
        if is_glocalx_run:
            run = load_run(rules)
            fine_boundary = run[&#39;rules&#39;]
            glocalx = GLocalX(oracle=run[&#39;oracle&#39;])
        else:
            fine_boundary = Rule.from_json(rules)
            glocalx = GLocalX(oracle=None)
    elif isinstance(rules, set) or isinstance(rules, list):
        fine_boundary = rules
        glocalx = GLocalX(oracle=None)
    else:
        raise ValueError(&#39;Not a str or set or list&#39;)

    # Load rules in the boundary
    glocalx.fine_boundary = fine_boundary

    return glocalx</code></pre>
</details>
</dd>
<dt id="serialization.load_run"><code class="name flex">
<span>def <span class="ident">load_run</span></span>(<span>run_file)</span>
</code></dt>
<dd>
<div class="desc"><p>The rules file output by GLocalX is slightly different than the input one loaded
with models.Rule.from_json, as it contains additional information on the run, such as
the input files paths, hyperparameters, etc.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>run_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the rules file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary holding the output rules (<code>rules</code> key), the oracle, if any, (<code>black_box</code>) key,
the training set (<code>tr</code> key) and the undersample (<code>undersample</code> key). Note that regardless
of whether the black box is loaded or not, the training set preserves its original labels.
If you want to use the training set with the black box labels you have to re-infer them.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_run(run_file):
    &#34;&#34;&#34;
    The rules file output by GLocalX is slightly different than the input one loaded
    with models.Rule.from_json, as it contains additional information on the run, such as
    the input files paths, hyperparameters, etc.
    Args:
        run_file (str): Path to the rules file.

    Returns:
        dict: Dictionary holding the output rules (`rules` key), the oracle, if any, (`black_box`) key,
                the training set (`tr` key) and the undersample (`undersample` key). Note that regardless
                of whether the black box is loaded or not, the training set preserves its original labels.
                If you want to use the training set with the black box labels you have to re-infer them.
    &#34;&#34;&#34;
    if not os.path.isfile(run_file):
        raise ValueError(&#39;File &#39; + str(run_file) + &#39; is not a file.&#39;)
    with open(run_file, &#39;r&#39;) as log:
        dic = json.load(log)

    # Load features names from the training file
    tr_path = dic[&#39;tr&#39;]
    if not os.path.isfile(tr_path):
        raise ValueError(&#39;Training file &#39; + str(tr_path) + &#39; is not a file.&#39;)
    data = np.genfromtxt(tr_path, delimiter=&#39;,&#39;, names=True)
    names = data.dtype.names
    tr_set = data.view(np.float).reshape(data.shape + (-1,))

    # Load rules
    rules = dic[&#39;rules&#39;]
    premises = [{int(k): v for k, v in d.items() if k != &#39;consequence&#39; and k != &#39;label&#39;} for d in rules]
    consequences = [dic[&#39;consequence&#39;] if &#39;consequence&#39; in dic else dic[&#39;label&#39;] for dic in rules]
    rules = [Rule(premises=premise, consequence=consequence, names=names)
             for premise, consequence in zip(premises, consequences)]

    # Load oracle
    oracle = dic[&#39;oracle&#39;]
    if oracle.endswith(&#39;.h5&#39;):
        oracle = load_tf_model(oracle)
    elif oracle.endswith(&#39;.pickle&#39;):
        with open(oracle, &#39;rb&#39;) as log:
            oracle = pickle.load(log)
    else:
        return

    # Load undersample
    undersample = dic[&#39;undersample&#39;]

    results = {
        &#39;rules&#39;: rules,
        &#39;oracle&#39;: oracle,
        &#39;undersample&#39;: undersample,
        &#39;tr&#39;: tr_set
    }

    return results</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="serialization.load_glocalx" href="#serialization.load_glocalx">load_glocalx</a></code></li>
<li><code><a title="serialization.load_run" href="#serialization.load_run">load_run</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>